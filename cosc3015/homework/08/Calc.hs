module Calculator_class where

------------------------------------------------------------------------
-- The Exp Type / abstract syntax trees to represent programs
------------------------------------------------------------------------

data Exp =
  C Int |                          -- constants
  V String |                       -- variables
  D String Exp |                   -- D x e declares variable x
                                   --   to have the value of expression e
  Let String Exp Exp |             -- let expressions
  Plus Exp Exp |                   -- addition
  Minus Exp Exp |                  -- subtraction
  Times Exp Exp |                  -- multiplication
  Div Exp Exp |                    -- integer division
  Eq Exp Exp |                     -- equality test
  If Exp Exp Exp |                 -- if-then-else
  Fun String [String] Exp |        -- function declaration
  Call String [Exp] |              -- function call
  Seq [Exp]                        -- a sequencing operator

------------------------------------------------------------------------
-- Instantiation of Show for the Expression type
-----------------------------------------------------------------------

instance Show Exp where
    show (C k) = show k
    show (V k) = show k
    show (D s k) = show s ++ ":=" ++ show k
    show (Let s e1 e2) = "Let " ++ show s ++ " = (" ++ show e1 ++ ") in (" ++ show e2 ++ ")"
    show (Plus e1 e2) = show e1 ++ " + " ++ show e2
    show (Minus e1 e2) = show e1 ++ " - " ++ show e2
    show (Times e1 e2) = show e1 ++ " * " ++ show e2
    show (Div e1 e2) = show e1 ++ " / " ++ show e2
    show (Eq e1 e2) = show e1 ++ " == " ++ show e2
    show (If e1 e2 e3) = "If " ++ show e1 ++ " then: " ++ show e2 ++ " else: " ++ show e3
    show (Call _ []) = show ""
    show (Call s es) = show s ++ " ->\n" ++ show (head es) ++ ";\n" ++ show (Seq (tail es))
            -- call to Seq is used to make printing pretty
    show (Fun f [] e1) = show f ++ "(--) -> " ++ show e1
    show (Fun f (s:[]) e1) = show f ++ "(" ++ show s ++ ")" ++ show e1
    show (Fun f ss e1) = show f ++ "(" ++ show ss ++ ") -> " ++ show e1
    show (Seq []) = ""
    show (Seq es) = show (head es) ++ ";\n" ++ show (Seq (tail es))

------------------------------------------------------------------------
-- The Assignment Type / for remembering the values of variables and functions
-----------------------------------------------------------------------

-- An Assignment is a Haskell record containing 2 components
-- val - for looking up variable values
-- fun - for looking up functions
-- we're using Association lists here instead of functions since lists can be displayed reasonably.
-- If you don't know what an association list is - Google it.

data Assignment = A {val:: [(String, Int)],
                     fun ::[(String,([String], Exp))]} deriving Show

assoc [] x = error ("assoc: " ++ x ++ " not found.")
assoc ((y,z):ys) x = if x == y then z else assoc ys x


-- a0 is an empty Assignment
a0 = A {val = [], fun = []}

-- the functions to add/get a value to the val/fun part of an Assignment
update_val a (x,v) = a {val = ((x,v) : (val a))}

update_vals :: Assignment -> ([String], [Int]) -> Assignment
update_vals a (strings, values) = a {val = s_v_pairs ++ (val a)}
    where s_v_pairs = zip strings values

get_val a x  = assoc (val a) x


-- the functions
update_fun a (f,(parms,body))  = a {fun = ((f,(parms,body)) : (fun a))}
get_fun a x = assoc (fun a) x

-- We interpret integers as Boolean values as in C++
--   false is 0
--   true - is any non-zero value
true b = (b /= 0)
false b = (b == 0)

------------------------------------------------------------------------------
-- Expression Evaluator / eval is a function to evaluate expressions
------------------------------------------------------------------------------
-- eval a e - evalutes expression e using Assignment a
--            it retuens a pair (i,a) where i is the result of evaluating
--            expression e and a is the assignment generated by evaluating
--            e.  Note that for example (eval a (Fun "id" ["x"] (V x))
--            is the identity function and will update the assignment.
------------------------------------------------------------------------------

eval :: Assignment -> Exp -> (Int, Assignment)

-- to evaluate a constant - just return the value
eval a (C k) = (k, a)

-- to evaluate a variable (V x) lookup the value of x in the assignment a
eval a (V x) = (get_val a x, a)

-- to evaluate a variable declaration (A x e), evaluate e resulting in
--      a pair (k, a1). Update the assignment a1 so that x is bound to k in
--      the new assignment.
eval a (D x e) = (k, a2)
     where (k, a1) = eval a e
           a2 = update_val a1 (x, k)

-- to evaluate (Let x e1 e2) evaluate e2 in the assignment a2 which has
--                  been updated to have x bound to the result of
--                  of evaluating e1 in assignment a.
eval a (Let x e1 e2) =  eval a2 e2
     where (k, a1)  = eval a e1
           a2 =  update_val a1 (x,k)

--  to evaluate (Plus e1 e2) evaluate e1 resulting in the value j
--          and possibly new assignment a1, then use a1 to evaluate e2
--          resulting in the value k and assignment a2. Return (j+k)
--          paired with the assignment a2.
eval a (Plus e1 e2) = (j + k, a2)
     where (j, a1) = eval a e1
           (k, a2) = eval a1 e2

--  to evaluate (Minus e1 e2) evaluate e1 resulting in the value j
--          and possibly new assignment a1, then use a1 to evaluate e2
--          resulting in the value k and assignment a2. Return (j-k)
--          paired with the assignment a2.
eval a (Minus e1 e2) = (j - k, a2)
     where (j, a1) = eval a e1
           (k, a2) = eval a1 e2

--  to evaluate (Times e1 e2) evaluate e1 resulting in the value j
--          and possibly new assignment a1, then use a1 to evaluate e2
--          resulting in the value k and assignment a2. Return (j * k)
--          paired with the assignment a2.

eval a (Times e1 e2) = (j * j, a2)
     where (j, a1) = eval a e1
           (k, a2) = eval a1 e2

--  to evaluate (Div e1 e2) evaluate e1 resulting in the value j
--          and possibly new assignment a1, then use a1 to evaluate e2
--          resulting in the value k and assignment a2. Return (j `div` k)
--          paired with the assignment a2.
eval a (Div e1 e2) = (v1 `div` v2, a2)
     where (v1, a1) = eval a e1
           (v2, a2) = eval a1 e2

eval a (Eq e1 e2) = (v, a2)
     where v = if v1 == v2 then 1 else 0
           (v1, a1) = eval a e1
           (v2, a2) = eval a1 e2

--  to evaluate (If e1 e2 e3) evaluate e1 resulting in the value b
--          (an integer interpreted as a Boolean).  There will be a
--          possibly new assignment a1. Then, of b is true,  use a1
--          to evaluate e2 using a1, if b is not true, then evaluate
--          e3 using assignment a1.

eval a (If e1 e2 e3) = if true b then (eval a1 e2) else (eval a1 e3)
     where (b, a1) = eval a e1

-- to evaluate a function declaration (Fun f parameters e), update the fun
--         part of the assignment a so that f is bound to the pair
--         (parameters, e) where parameters is the
--         list of parameter names, and e is the body of the function f.
--         Arbitraily, return 1 (true) as the value of a function declaration.

eval a (Fun f parameters body) = (1, update_fun a (f, (parameters, body)))

-- to evalue a function call (Call f args) - recall, args is a list of
-- expressions (say [a_1,...,a_k]).  Lookup f in the fun part of
-- assignment a. If f is in the assignment, the lookup will return a
-- pair (parameters, body) where parameters is the list of parameter
-- names (say [p_1,..,p_k]), and body is the expression defining f.
-- Create a new assignment (a') by updating the assignment (a) so that
-- each p_i, gets paired with the value part of (eval a a_i).  Return
-- the value part of (eval a' body) paired with the original
-- assignment (a).

eval a (Call f args) = (val, a)
     where (parms, body) = get_fun a f
           a' = update_vals a (parms, map (fst . eval a) args)
           (val, _) = eval a' body

-- Here's the code you need to work fix.

eval a (Seq es) = evalseq a es

-- helper functions for evaluating sequences
evalseq a (e:[]) = eval a e
evalseq a (e:es) =  evalseq a1 es
    where (_, a1) = eval a e

-- here are some example inputs that i used to verify the new eval for sequences
-- using the below bindings for an assignment set as well
-- let a = update_val a1 ("x", 5) where a1 = update_val a0 ("y", 6)

-- eval a (Seq [(Plus (V "x") (V "y"))])
-- Output: (11,A {val = [("x",5),("y",6)], fun = []})

-- eval a (Seq [(Plus (V "x") (C 10)), (C 101), (V "y")])
-- Output: (6,A {val = [("x",5),("y",6)], fun = []})

-- eval a (Seq [(Plus (V "x") (C 10)), (C 101), (C 102)])
-- Output: (102,A {val = [("x",5),("y",6)], fun = []})
